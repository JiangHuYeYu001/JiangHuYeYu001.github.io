### 前言：linux的文件结构是树状的，一层一层又一层。其自带语法，利用../可以回溯到上一级的目录中。例如一个随意的目录文件/var/www/html/admin/lfi.php，我们想要利用../的语法得到/etc/passwd，路径拼接后完整路径是：/var/www/html/admin/../../../../../../../../etc/passwd，从左到右解析
admin/../ → 抵消 admin，得到 /var/www/html/；
html/../ → 抵消 html，得到 /var/www/；
www/../ → 抵消 www，得到 /var/；
var/../ → 抵消 var，得到 /（根目录）；
剩下的 ../../../../：此时已经在根目录 /，所有多余的 ../ 全部被忽略；
最终简化为：/etc/passwd（正确路径）
哪怕目标文件不在根目录（比如在 `/var/www/config.php`、`/home/user/test.txt` 这类“中间目录”），**多余的 `../` 依然不会影响结果**——核心还是 Linux 的「路径归一化规则」在起作用：多余的 `../` 会被自动忽略，只要最终拼接后的路径能指向目标文件，无论 `../` 多写多少，都会被简化为正确路径。
## 那么假设我需要的文件不在根目录的话，是不是需要输入数目准确的../才可以
别急，且细细说来。实际上，不在根目录的时候，你只要知道它到底根目录下面的哪一层就可以。
### 一、核心逻辑：归一化规则“通杀”所有场景
不管目标文件在根目录、中间目录还是用户家目录，Linux 解析路径时都会先“处理所有 `../`”，再定位目标文件。关键规律是：
- 当 `../` 的数量 ≥ “当前目录到根目录的层数”时：所有多余的 `../` 都会被忽略（因为已经到根目录了，再往上还是根目录）；
- 之后，剩下的“目标路径部分”会从「根目录」开始拼接，最终指向正确文件。

简单说：**目标文件在不在根目录，只影响“目标路径的后半部分”，不影响“多余 `../` 的处理逻辑”** ——多余的 `../` 只会“多走几步回头路到根目录”，之后还是会按你写的目标路径找文件。


### 二、直观例子：目标文件不在根目录，多写 `../` 依然生效
假设场景：
- 当前工作目录（Web 脚本所在目录）：`/var/www/html/admin/user/`（深度：5 层，从根目录 `/` 到 `user/` 需经过 `var→www→html→admin→user`）；
- 目标文件（不在根目录）：`/var/www/config.php`（在 `/var/www/` 目录下，属于“中间目录”）。

#### 情况1：写“准确层数”的 `../`
当前目录到目标文件的准确回溯层数：`user/` → `admin/`（1个`../`）→ `html/`（2个`../`）→ `www/`（3个`../`），此时到达 `/var/www/`，再拼接 `config.php`，所以准确路径是：
```
../../../config.php
```
Linux 解析后：`/var/www/html/admin/user/../../../config.php` → 简化为 `/var/www/config.php`（正确）。

#### 情况2：写“多余层数”的 `../`（比如多写3个，共6个）
构造路径：
```
../../../../../../config.php （6个../，比准确层数多3个）
```
Linux 解析过程（一步步归一化）：
1. 完整路径：`/var/www/html/admin/user/../../../../../../config.php`；
2. 先处理 `../`：
   - 1个`../`：`user/../` → 抵消 `user`，得到 `/var/www/html/admin/`；
   - 2个`../`：`admin/../` → 抵消 `admin`，得到 `/var/www/html/`；
   - 3个`../`：`html/../` → 抵消 `html`，得到 `/var/www/`；
   - 4个`../`：`www/../` → 抵消 `www`，得到 `/var/`；
   - 5个`../`：`var/../` → 抵消 `var`，得到 `/`（根目录）；
   - 6个`../`：当前已在根目录 `/`，多余的这个 `../` 被直接忽略；
3. 最终简化路径：`/config.php`？不！等一下——这里容易误解，再仔细看：
   哦，目标文件的路径是 `config.php`，但我们的核心需求是“从当前目录回溯到 `/var/www/` 再找 `config.php`”，但如果多写了 `../`，是不是会错？  
   别急，换个更贴近实际的构造：目标文件是 `/var/www/config.php`，我们可以直接拼接“目标文件的绝对路径后半部分”，比如：
   ```
   ../../../../../../var/www/config.php （6个../ + 目标文件的绝对路径）
   ```
   解析过程：
   - 6个`../` 把路径回溯到根目录 `/`（多余的 `../` 被忽略）；
   - 剩下的 `var/www/config.php` 从根目录开始拼接，最终路径是 `/var/www/config.php`（完全正确）！

#### 关键结论：
哪怕目标文件在中间目录，你也可以：
1. 先写“足够多的 `../`”（比如 6-8 个，确保能回溯到根目录）；
2. 再拼接目标文件的「绝对路径后半部分」（比如 `/var/www/config.php` 直接写 `var/www/config.php`，不用加开头的 `/`）；
3. Linux 会自动归一化为 `/{目标文件绝对路径}`，精准命中目标。


### 三、再举1个渗透测试常见例子（目标文件不在根目录）
场景：
- Web 脚本路径：`/var/www/html/blog/article/`（当前目录）；
- 目标文件：`/var/log/apache2/access.log`（不在根目录，在 `/var/log/` 下）；
- 构造 Payload（多写 `../`）：
  ```
  http://target.com/lfi.php?file=../../../../../../../../var/log/apache2/access.log
  ```
解析过程：
1. 拼接后的完整路径：`/var/www/html/blog/article/../../../../../../../../var/log/apache2/access.log`；
2. 处理 `../`：前 5 个 `../` 已回溯到根目录 `/`（`article→blog→html→www→var→/`）；
3. 剩下的 3 个 `../` 被忽略（根目录没有上一级）；
4. 最终简化为：`/var/log/apache2/access.log`（完全正确，和目标文件路径一致）。


### 四、为什么“不在根目录”也不用算准确层数？
核心原因：**目标文件的“最终路径”是“根目录 + 目标文件的绝对路径部分”**，而多余的 `../` 只会让路径“先回溯到根目录”，之后再从根目录出发找目标文件——这和“直接写绝对路径”的效果完全一致。

你可以把这个过程想象成：
- 你要去商场的 3 楼餐厅（目标文件：`/商场/3楼/餐厅`）；
- 你现在在商场的 5 楼电影院（当前目录：`/商场/5楼/电影院`）；
- 你不用精确算“下 2 层”，可以直接“下 10 层”（多余的 `../`）——下到 1 楼（根目录）后，再往上走 2 层到 3 楼餐厅，最终还是能到达目标。


### 五、渗透测试中的实践技巧（关键！）
不管目标文件在不在根目录，实际利用时都**不需要算“准确层数”**，推荐直接这么做：
1. 写足够多的 `../`（比如 6-10 个，如 `../../../../../../`）；
2. 后面直接拼接目标文件的「绝对路径后半部分」（不用加开头的 `/`）；
   - 比如目标 `(/var/www/config.php)` → 拼接 `var/www/config.php`；
   - 比如目标 `(/home/user/.bash_history)` → 拼接 `home/user/.bash_history`；
3. 最终 Payload 类似：
   ```
   http://target.com/lfi.php?file=../../../../../../var/www/config.php
   http://target.com/lfi.php?file=../../../../../../home/user/.bash_history
   ```

这样做的好处：不用猜测当前 Web 脚本的目录深度（比如是 `/html/` 还是 `/html/admin/user/`），利用 Linux 归一化自动容错，成功率几乎 100%。


### 总结
无论目标文件在根目录还是中间目录，**多余的 `../` 都不会影响结果**——Linux 路径归一化会自动忽略超出“当前目录到根目录层数”的 `../`，最终只看“`../` 处理完后剩下的目标路径”。

渗透测试中，永远不用纠结“`../` 要写几个才准确”：直接多写几个，后面拼接目标文件的绝对路径后半部分，利用归一化规则“自动修正”，高效又稳妥。